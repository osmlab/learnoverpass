<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><title>By Tag</title><link rel="stylesheet" href="//osmlab.github.io/learnoverpass//css/main.css"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png"><link href="/favicon.png" rel="icon"><link href='https://fonts.googleapis.com/css?family=Roboto:400,300,700' rel='stylesheet' type='text/css'><link href="" rel="alternate" type="application/rss+xml" title="LearnOverpass &middot; "/><meta name="description" content=""><meta name="keywords" content=""> </head><body><div class="exercise-contrib"><div> <a href="https://github.com/osmlab/learnoverpass/blob/master/CONTRIB.md">Contribute to project</a></div></div><div class="row"><div class="docs-list"> <header><a href="//osmlab.github.io/learnoverpass//"><h1 class="header-title"> LearnOverpass</h1></a></header><ul>  <li class="docs-list-title"> <strong>Block Queries</strong></li> <li class=""> <a href="/learnoverpass/en/docs/block-queries/union/">Union</a></li> <li class=""> <a href="/learnoverpass/en/docs/block-queries/difference/">Difference</a></li> <li class=""> <a href="/learnoverpass/en/docs/block-queries/foreach/">For-each loop (foreach)</a></li>  <li class="docs-list-title"> <strong>Standalone Queries</strong></li> <li class=""> <a href="/learnoverpass/en/docs/standalone-queries/item/">Item</a></li> <li class=""> <a href="/learnoverpass/en/docs/standalone-queries/recurse-up/">Recurse Up (&lt;)</a></li>  <li class="docs-list-title"> <strong>Filters</strong></li> <li class="docs-list-active"> <a href="/learnoverpass/en/docs/filters/tag/">By Tag</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/bbox/">Bounding Box</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/recurse/">Recurse (n, w, r, bn, bw, br)</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/input-set/">By Input Set</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/element-id/">By Element Id</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/around/">Relative to other elements (around)</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/polygon/">By polygon (poly)</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/newer/">Newer</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/changed/">By date of change (changed)</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/user/">By user (user, uid)</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/area/">By area (area)</a></li> <li class=""> <a href="/learnoverpass/en/docs/filters/pivot/">Area pivot (pivot)</a></li>  <li class="docs-list-title"> <strong>Actions</strong></li> <li class=""> <a href="/learnoverpass/en/docs/actions/print/">Print (out)</a></li>  </ul></div><div class="docs-content"><div class="content"> <script>
  (function() {
    var cx = '015815945200332182951:xrisyx6jrce';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script><gcse:search></gcse:search><h1 id="post-title"> By Tag <small> <a class="docs-improve" href="https://github.com/osmlab/learnoverpass/edit/master/content/en/docs/filters/tag.md">Improve page</a></small></h1><p>

<p>The has-kv filter selects all elements that have or have not a tag with a certain value. It supports the basic OSM types node, way, and relation as well as the extended type area.</p>

<p>It has no input set. As for all filters, the result set is specified by the whole statement, not the individual filter.</p>

<p>All variants consist of an opening bracket, then a string literal in single or double quotes. Then the variants differ. All variants end with a closing bracket. If the string literal consists only of letters, the quotes can be omitted.</p>

<h3 id="equals">Equals (=, !=)</h3>

<p>The most common variant selects all elements where the tag with the given key has a specific value. This variant contains after the key literal an equal sign and a further literal containing the value. Examples, all equivalent:</p>

<pre><code>node[&quot;name&quot;=&quot;Foo&quot;];
node[name=Foo];
node['name'=&quot;Foo&quot;];
node[name=&quot;Foo&quot;];
node[&quot;name&quot;='Foo'];
</code></pre>

<p>If you have a digit, whitespace or whatever in the value, you do need single or double quotes:</p>

<pre><code>node[&quot;name&quot;=&quot;Foo Street&quot;];
node[&quot;name&quot;='Foo Street'];
node[name=&quot;Foo Street&quot;];
</code></pre>

<p>Querying for empty values is not possible using the equals value operator. This can only be achieved by using a regular expression:</p>

<pre><code>node[power=&quot;&quot;];          // not supported
node[power~&quot;^$&quot;];        // use regular expression instead
</code></pre>

<p>Likewise, querying empty key values is also not possible using this kind of key-value query and needs to be expressed via regular expressions.</p>

<pre><code>node[~&quot;^$&quot;~&quot;.&quot;];         // find nodes with empty key (&quot;&quot;) and any value
</code></pre>

<p>NB: Overpass Turbo Wizard already has some logic in place to automatically convert &ldquo;&rdquo;=&ldquo;&rdquo; accordingly.</p>

<h3 id="exists">Exists</h3>

<p>The second variant selects all elements that have a tag with a certain key and an arbitrary value. It contains nothing between the key literal and the closing bracket:</p>

<pre><code>node[&quot;name&quot;];
node['name'];
node[name];
</code></pre>

<h3 id="value-matches-regular-expression">Value matches regular expression (~, !~)</h3>

<p>The third variant selects all elements that have a tag with a certain key and a value that matches some regular expression. It contains after the key literal a tilde, then a second literal for the regular expression to search for:</p>

<pre><code>node[&quot;name&quot;~&quot;^Foo$&quot;];    /* finds exactly &quot;Foo&quot; */
node[&quot;name&quot;~&quot;^Foo&quot;];     /* finds anything that starts with &quot;Foo&quot; */
node[&quot;name&quot;~&quot;Foo$&quot;];     /* finds anything that ends with &quot;Foo&quot; */
node[&quot;name&quot;~&quot;Foo&quot;];      /* finds anything that contains the substring &quot;Foo&quot; */
node[&quot;name&quot;~&quot;.&quot;];        /* finds anything, equal to the previous variant */
</code></pre>

<p>Please note that in QL you need to escape backslashes: [&ldquo;name&rdquo;~&ldquo;^St.&rdquo;] results in the regular expression ^St. (which finds every name starting with &ldquo;St&rdquo;), while [&ldquo;name&rdquo;~&ldquo;^St\.&ldquo;] produces the most likely meant regular expression St. (which finds every name starting with &ldquo;St.&rdquo;). This is due to the C escaping rules and doesn&rsquo;t apply to the XML syntax.</p>

<p>You can also search case insensitively:</p>

<pre><code>node[&quot;name&quot;~&quot;^Foo$&quot;,i];    /* finds &quot;foo&quot;, &quot;FOO&quot;, &quot;fOo&quot;, &quot;Foo&quot; etc. */
</code></pre>

<p>Both the key and value variants with and without regular expressions can be negated. They then select exactly the elements which have a tag with the given key, but no matching value and the elements that don&rsquo;t have a tag with the given key:</p>

<pre><code>node[&quot;name&quot;!=&quot;Foo&quot;];
node[&quot;name&quot;!~&quot;Foo&quot;];
node[&quot;name&quot;!~&quot;Foo&quot;,i];
</code></pre>

<p>Key/value matches regular expression (~&ldquo;key regex&rdquo;~&ldquo;value regex&rdquo;)
The forth variant selects all elements where both key and value match a regular expression. After an initial tilde (~) the regular expression for the key needs to be provided, followed by another tilde character and eventually the regular expression for the value.</p>

<pre><code>node[~&quot;^addr:.*$&quot;~&quot;^Foo$&quot;];    /* finds addr:* tags with value exactly &quot;Foo&quot; */
node[~&quot;^addr:.*$&quot;~&quot;^Foo&quot;];     /* finds addr:* tags with value starting with &quot;Foo&quot; */
node[~&quot;^addr:.*$&quot;~&quot;Foo$&quot;];     /* finds addr:* tags with value ending with &quot;Foo&quot; */
node[~&quot;^addr:.*$&quot;~&quot;Foo&quot;];      /* finds addr:* tags with value containing the substring &quot;Foo&quot; */
node[~&quot;^addr:.*$&quot;~&quot;.&quot;];        /* finds addr:* tags with any value */
</code></pre>

<p>Regular expressions for values cannot be negated in this variant.
<div class="docs-repl">  <textarea>
// Filter and only get nodes that are banks.
node[amenity=bank]
(47.06,15.42,47.09,15.48); // a bbox-filter
out;
</textarea><div class="docs-repl-result">  <iframe src="https://overpass-turbo.eu/map.html?silent&Q=%0a%2f%2f%20Filter%20and%20only%20get%20nodes%20that%20are%20banks.%0anode%5bamenity%3dbank%5d%0a%2847.06%2c15.42%2c47.09%2c15.48%29%3b%20%2f%2f%20a%20bbox-filter%0aout%3b%0a"  seamless="seamless" frameBorder="0" width="100%;"></iframe><textarea></textarea> <a class="docs-repl-change-output button" href="#">Data</a></div></div></p>
</p> <footer><p>Website released under MIT License. Documentation and Courses under GNU FDL. &copy; 2015</p> <small class="language-switch">     <a lang='en' href="//osmlab.github.io/learnoverpass//en/docs/filters/tag/">English</a> | <a lang='de' href="//osmlab.github.io/learnoverpass//de/docs/filters/tag/">Deutsch</a></small></footer></div></div></div> <script src="//osmlab.github.io/learnoverpass//js/vendor.bundle.js"></script> <script src="//osmlab.github.io/learnoverpass//js/docs.bundle.js"></script> </body></html>